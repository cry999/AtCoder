# AtCoder Beginner Contest 129

寝てて参加し損ねた。

## A

:o:

`P+Q` `Q+R` `R+P` の最小のもの。`O(1)`

## B

:o:

`W` の累積和をとれば `O(N)`。`T` について毎回愚直に `S1` `S2` を計算しても `O(N^2) = O(10000)` 程度なので大丈夫。

## C

:o:

`dp[n] = n 段目にたどり着く方法` とすると

```math
dp[n+2] = dp[n+1] + dp[n] (n+2 != a[i]; all i)
dp[n+2] = 0               (n+2 == a[i]; any i)
```

が成り立つ。つまりは少し特殊なフィボナッチ数列。この数式を直接計算すると `n+2` が `a` に含まれるかどうかで `O(logM)` (ただし、`a` はソートされている前提) かかるので全体で `O((N+M)logM)`

うまいこと `a` のインデックスを持ちながら計算すれば `O(N)` で計算できる。

## D

:o:

`UnionFind` を使って縦あるいは横方向のみを考えた連結部分をグループ分けし、グループにその方向の長さを紐づけることで各連結部分の長さの計算を合計 `O(H*W)` 長さの取得を `O(1)` で実現できるようにした。

`O(H*W)`

解説のやり方の方がずっとスマート。

## E

:x:

桁 dp が身につかない。

`O(log L)`

## F

:x:

`O(log Cd)`
