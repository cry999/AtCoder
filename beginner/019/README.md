# AtCoder Beginner Contest 019

## A

:o:

ソートして真ん中をとる。`O(N logN)`

## B

:o:

問題文通りにシミュレートする。`O(|s|)`

## C

:x:

ある値を見つけたらそれの 2 倍の数をすべて消すということをしながらカウントするようにしたら `WA`。解説の、最初に全ての数字を割り切れなくなるまで 2 で割るという手法との違いが判らん。`O(N logN)`

## D

:o:

1. `1` とその他の全ての頂点の距離を尋ねる。(質問回数 N-1)
2. `1` から最も遠い頂点を見つける。これを `v` とする。
3. このとき、考えられる最遠頂点の組は `v` となにかしらの組となる。なぜなら、`v` が最遠頂点の組に使われていないと仮定し、この最遠頂点の組を `(u1, u2)` とする。また、頂点 `a` と `b` の距離を `d(a, b)` と表す。
   
    1. `v` と `u1` `u2` のいずれかが `1` から見て異なる方向にあるとき
        
        仮に、`v` と `u1` が `1` からみて異なる方向にあるとする。このとき、
        
        ```math
        d(v, u1) = d(v, 1) + d(1, u1)
                 > d(u2, 1) + d(1, u1)
                 = d(u2, u1)
        ```

        となり、仮定に反する。

    2. `v` と `u1` `u2` のすべてが同じ方向にあるとき
        
        この場合は、`v` `u1` `u2` の `LCA` と `1` を置き換えて上述の議論を展開すれば同様に証明できる。
4. 3. より `v` とほかの頂点の組み合わせを考えればいいことが判ったので、あとは全探索でよい。`v` とほか全ての頂点の距離を尋ねる。(質問回数は N-1)
5. 4. の値の最大値が木の直径。

以上。質問回数は `(N-1) + (N-1) = 2*N-2 <= 98 < 100` で足りる。計算量は `O(N)`
