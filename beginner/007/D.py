def f(k: int)->int:
    '''
    k 桁の数の 4 と 9 を利用した数がわかっている(f(k))とする。

    このとき 1 <= n <= 9 かつ n != 4 かつ n != 9 を満たす n
    について最上位の数字が n で (k+1) 桁の数字の中の 4 と 9 を
    利用している数字の数は f(k) となる。

    n = 4 または n = 9 の時は全てダメなので、10^(k-1) 個になる。

    したがって、f(k+1) = 8*f(k) + 2*10^(k-1)
    '''
    if k < 1:
        return 0
    return 8*f(k-1) + 2*(10**(k-1))


def g(n: int)->int:
    '''1 から n に含まれる禁止数字の個数を求める。
    例えば、n = ak*10^k + a{k-1}*10^(k-1) + ... + a{0}*10^0
    と表せるとする。(0 <= ai <= 9, ak != 0)

    この時、(ak-1) * f(k+1) が [1, ak*10^k) に含まれる禁止文字列
    となる。ただし、ak が 0,5 の時は注意が必要。
    さらに、(a{k-1}-1) * f(k+1) を加えれば [1, ak*10^k + 
    a{k-1}*10^(k-1)) に含まれる禁止文字列が求まる。
    以下、これを繰り返せば、[1, n] に含まれる禁止文字列が求まる。
    '''
    # 文字列にした方が最上位から処理しやすい
    s = str(n)
    max_k, k = len(s), len(s)

    res = 0
    for c in s:
        i = int(c)
        if i < 4:
            # 例えば、i = 3 の時
            # (0 で始まる k 桁) + (1 で ~) + (2 で ~)
            # となるのでこれが i*f(k) と対応する。
            # これで [1, 3*10^(k-1)) が求まり、あとは 3*10^(k-1)
            # の判定だが、これは明らかに禁止数字でないので足さなくて
            # OK
            res += i*f(k-1)
        elif i == 4:
            # (0 で始まる k 桁) + (1 ~) + ... + (3 ~)
            # に関して 4*f(k)
            # また、残りの ak a{k-1} ... ai 00..0 以降の
            # 判定について、常に 4 が含まれる(ai)ので確実に禁止文字列
            # したがって、これ以下の数字を加える。
            # 例えば n=123456 だとすると、今 res = g(123000)
            # res + 4*f(k) で res = g(123399)
            # このあと、123400 から 123456 までは必ず 4 が含まれるので
            # 全部禁止数字列。したがって、この 4 以下の 456 + 1 を加える。
            # 以下の判定も不要。
            res += i*f(k-1)
            res += int(s[max_k-k+1:] if s[max_k-k+1:] else '0') + 1
            break
        elif i < 9:
            # 基本的には i < 4 の時と同じ考え方だが、頭が 4 の時を丸っと
            # 加える。
            res += (i-1)*f(k-1) + 10 ** (k-1)
        else:  # i == 9
            # 基本的に i == 4 の場合と同じ考え方だが、ここでも頭が 4 の時の
            # 加算について注意。
            res += (i-1)*f(k-1) + 10 ** (k-1)
            res += int(s[max_k-k+1:] if s[max_k-k+1:] else '0') + 1
            break
        k -= 1
    return res


def forbidden_number(A: int, B: int)->int:
    '''1 から N に含まれる 4 か 9 のいづれかを含む数字の数を
    求める。これを g(N) とする。g(B) - g(A-1) が [A, B] に
    含まれる 4 か 9 のいづれかを含む数字の個数となる。
    '''
    return g(B) - g(A-1)


if __name__ == "__main__":
    A, B = map(int, input().split())

    ans = forbidden_number(A, B)
    print(ans)
