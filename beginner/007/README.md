# AtCoder Beginner Contest 007

## A

:o:

`n-1`。`O(1)`

## B

:o:

`A` が `'a'` でない時以外は、`A` より `'a'` の方が必ず小さいのでこれを返す。`A='a'` の場合はそれより小さいものは存在しないので `-1` を返す。`O(1)`

## C

:o:

問題文に全て書いてある。移動コストが常に `1` なので基本的に最初に訪れた時しかますの最短距離は更新されない。したがって、計算量は `O(RC)`

## D

:o:

頑張った。`O(log(AB))`

まず `k` 桁の数字の禁止数字列の数を `f(k)` とする。

この時、`k+1` 桁の数字の禁止数字列の数を数える。まず `n != 4` `n != 9` である一桁の数字 `n` (0 を許容)で始まる `k+1` 桁の数字については、最上位以外の `k` 桁の組み合わせを考えれば良いので `f(k)` となる。`n = 4` または `n = 9` の場合は他の数字がなんであれ禁止数字列なので、`10^k` 個となる。

以上をまとめると、

```math
f(k+1) = 8*f(k) + 2 * 10^k
```

次に、`N` 以下の禁止数字列の個数を `g(N)` とする。

```math
N = ak * 10^k + ... + a0 * 10^0
```

とする。まず、`ak` から見ていく。`ak` _ 10^k 以下の禁止数字列の個数は、`f(k)` を利用して `ak _ f(k+1)`と表せる。これが`[1, ak*10^k]`の禁止数字列の個数。次に、`a{k-1}`を同様にみて、`a{k-1}*f(k)`が`[1, a{k-1}*10^(k-1)]`の禁止数字列の個数を表わす。さらに、`a{k-1}`より上位の桁が固定されていれば、`[1, a{k-1}*10^(k-1)]`の個数も`[ak*10^k+1, ak*10^k + a{k-1}*10^(k-1)]`の個数も同じなので、`ak*f(k+1) + a{k-1}*f(k)`が`[1, ak*10^k + a{k-1}*10^(k-1)]` の個数を表わす。

以上を繰り返すことで、`[1, N]` の禁止数字列の個数を求められる。ただし、`ak` が禁止数字列の場合は特別な処理が必要。

ここまで求まれば、`g(B) - g(A-1)` が `[A, B]` の禁止数字列の個数になる。
