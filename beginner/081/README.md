# AtCoder Beginner Contest 081

## A

:o:

`s` ないの `1` の数を数える。`O(|s|)`

## B

:o:

`A` の各項について 2 で割り切れる回数を調べ、その最小値を求める。`O(N log(max(A)))`

## C

:o:

各数字の出現頻度をとり、その出現頻度を大きい順に `K` 個無視した残りのあたいの和を取れば良い。`O(N logN)`

## D

:o:

全体が正の値の時は、1 から順番に `i` 番目の値を `i+1` 番目の値に足していけば良い。全体が負の時は逆に後ろから `i` 番目の値を `i+1` 番目の値に足していけばいい。どちらも操作回数は `N-1` 回。

問題は正と負の値が混在する時。この時は、`max(A)` と `min(A)` の絶対値を比較して、`max(A)` の絶対値の方が大きい場合は全体に `max(A)` を足すことで正の値のみに修正でき、`min(A)` の絶対値の方が大きい場合は全体に `min(A)` を加えることで負の値のみに修正できる。あとは上述の操作を行うだけ。正または負の値への統一操作に費やす操作回数は `N-1` 回。

以上より `2N` 回以内で単調増加するような数列に変更できる。

計算量は `O(N)`
