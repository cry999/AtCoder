# AtCoder Beginner Contest 147

## A

:o:

与えられた計算式を実装するだけ。

`O(1)`

## B

:o:

前から `i` 番目の文字と後ろから `i` 番目の文字が一致しなければカウントアップ。

`O(|S|)`

## C

:o:

`N <= 15` なのでそれぞれの人が正直者である場合と嘘つきである場合の全探索で十分間に合う。まず全ての人を正直者か嘘つきに仮定する。正直者の証言をチェックして仮定に矛盾がないかチェックする。OK だったら最大人数の更新、NG だったら次の仮定を行う。

`O(2^N)`

## D

:o:

尺取法。

`A` の全ての数字の 2 進数表示で `i` 桁目の数字の和を取っておく(`bit_sum[i]`)。`S[0] := SUM(A[0] XOR A[j]; j = 1, 2, 3, ..., N)` は以下のように計算する。

1. `bit_sum[i]` から `A[0]` の `i` 桁目の値を引いておく。
2. `A[0]` の `i` 桁目の値で場合わけ

   1. `A[0]` の `i` 桁目が `0`

      `A[0] XOR A[j] = 1` となるものだけが総和に貢献するのは自明。今、`A[0]` の `i` 桁目は `0` なので `A[j]` は `i` 桁目が `1` のものだけ考慮すれば良い。

      ```math
      ∴ S[0] += SUM(bit_sum[i] * 2^i; i = 0, 1, 2, ..., 59)
      ```

   2. `A[0]` の `i` 桁目が `1`

      上記と同様に考えれば必要な `A[j]` は `i` 桁目が `0` のものだけ。これは、`N` から `A[0]` をのぞき、さらに、`i` 桁目が `1` のものを除けば良いので、`N - 1 - bit_sum[i]` 個となる。

      ```math
      ∴ S[0] += SUM((N - 1 - bit_sum[i]) * 2^i; i = 0, 1, 2, ..., 59)
      ```

上記の手順を全ての `A[i]` に対して実行すれば良い。計算量自体は `O(N) = O(3*10^5)` だが定数倍が大きい(2 進数表記で各桁に対してループ回すので `60`)のか [Python 3](./D.py) では `TLE` だった。[D.cpp](./D.cpp) だと同じロジックでも通った。

`O(N)`

## E

:x:

## F

:x:
