# AtCoder Beginner Contest 126

完答。`00:69:51`

## A

:o:

問題文通り。`O(1)`

## B

:o:

最初の二桁を `A` 残りの二桁を `B` とする。`A` `B` それぞれが `1` から `12` の間に含まれるかの 4 通りで場合分け。`O(1)`

## C

:o:

- ダイスの目が `K` 未満の時、

  ダイスの目を `n` とすると、`log(K/n)` 回連続でコインの表を出さないと勝てない。また、得点が `K` 以上になった時点でゲーム終了なので、それ以上の試行を考える必要はない。したがって、`1 / (N * 2^log(K/n))`

- ダイスの目が `K`

  ダイス振った時点で終了。`1 / N`

これを `1` から `N` まで合算する。`O(N logK)`

## D

:o:

隣り合う頂点の色の関係だけ考えれば良い。`O(N)`

## E

:o:

`Z` が偶数の時 `A_X` と `A_Y` は同じで `Z` が奇数の時、`A_X` と `A_Y` は異なる。実は、`A_X` と `A_Y` が同じ値かどうかは関係なく、この時点で既に `A_X` か `A_Y` のどちらかが決まればもう一方も決まる。つまり、`Z` による分類は必要なく、`A_X` と `A_Y` を繋げていけば良い。これは `UnionFind` で実現できる。

あとは、このクエリに出てこなかったカードを一枚ずつ決定する。

つまり、全体としては `UnionFind` でクエリを処理して、集合の数を数えれば良い。`O(M logN)`

## F

:o:

`K` が `2^M` 以上のものは明らかにビットが足りなくて xor だけでは生成できないので、`K` が `2^M` 未満かどうかで作成可能かどうかを判定すれば良い。あとは、 `...xyzKzyx...K` のように構築すれば良い。ただし、`M = 0` の時には注意が必要。`O(2^M)`
