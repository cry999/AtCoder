# AtCoder Beginner Contest 021

## A

:o:

2 進数を求める問題。`O(logN)`

## B

:o:

重複を求める問題。`O(K logK)`

## C

:o:

まず全点対の最短距離を求める。今、点 `s` に対して隣接点の集合 `{yi}` があるとする。このとき、`t` への最短経路は必ず `{yi}` のいずれかを通り、`yi` を経由して `t` にたどり着くルートと、`yj` を経由して `t` にたどり着くルートは異なることは自明。したがって、`dp[s]` を 「`s` から `b` への最短経路の数」とすると、

```math
dp[s] = sum(dp[x], {x | x in (s の隣接点 and s は x を経由する最短経路をもつ)})
```

と定義できる。計算量は Warshal-Floyd 法がボトルネックで `O(N^3)`。

## D

:o:

最後に問題文の言い換えがあったからわかった。`1 <= a1 <= ... <= ak <= n` を満たす整数組 `(a1, a2, ..., ak)` の組み合わせは数字 `1 ~ n` と `k-1` 個の `|` の重複並び替えを考えれば良い。そうして、`i` 個目の `|` から左を見てもっとも右にある数字を `ai` とすれば良い。ただし、`|` が一番左にある組み合わせを除外するために、数字を `2 ~ N` に変更する。結局 `{(n-1)+(k-1)}_C_{k-1}` が答えになる。また、`{n+1}_C_{r+1} = (n+1)/(r+1) x {n}C{r}` である事実を利用すれば、`{n-1}_C_{0}` から計算を始めれば良いので計算量は `O(k)` となる。
