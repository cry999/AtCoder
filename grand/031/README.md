# AtCoder Grand Contest 031

## A

:o:

(1 + 出現回数) の積を取る。`O(N)`

## B

:o:

`dp[i]` を「 `i` 文字目までを処理した際の最終的な文字列のありうる個数」とする。この時、

```math
dp[i] = dp[i-1] + dp[j]  (j < i && i 番目の文字と j 番目の文字が同じ文字)
dp[i] = dp[i-1]          (上記以外)
```

が成り立つ。上の `(i, j)` のペアについてだが、`j` は `i` より左にあって最も近いものだけでいい。なぜなら、`j1 < j2 < i` を満たす `j1` と `j2` が存在する時、`(j1, i)` を塗りつぶす行為は `(j1, j2)` を塗りつぶした後に `(j2, i)` を塗りつぶすことで実現できるためである。

なんとか dp の実装までできたが、「 `10^9 + 7` で割ったあまりを求める」事を失念してい `WA` を出した。気をつけたい。

`O(N)`

## C

:o:

立っているビットの数の差が奇数なら OK で偶数なら NG だということまで気づけたが経路の出し方がさっぱりだった。

`N` ビットでハミング距離 1 の数列は `N` 次元の `N` 頂点の図形に対応する事が調べてわかったので、そこから次元を落とした `(N-1)` 次元のものと関連付けまで考えるべきだった。

`O(N^2 logN)`

## D

TODO: not implemented

## E

TODO: not implemented

## F

TODO: not implemented
