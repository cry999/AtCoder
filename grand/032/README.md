# AtCoder Grand Contest 032

## A

:o:

現在の数列 `A` を右から見ていき最初にインデックスと値が一致する数字が今回の操作で挿入された数字。なぜなら、インデックスと値が一致する数字 `i` `j` (`i < j`) が見つかったとき `i` が今回の操作で挿入された数字だとすると、前回の数列では `j` のインデックスは `j-1` でありそれ以前の操作でも `j` のインデックスは `j-1` 以下であり、`j` となることがない、つまりは `j` を挿入する操作が存在しないことになるからである。

計算量は `O(N^2)`

## B

:o:

`N` が偶数の時、`i` は `N+1-i` 以外の頂点と結べば隣接点の和は `(N+1)(N-2)/2` となり、`i` に依存しないため全て同じになる。

`N` が奇数の時、`N` を抜いた `N-1` 個の頂点に対して偶数の場合の処理をする。このとき、`N` 以外の頂点はその隣接点の和は `N(N-3)/2` となってい。この状態で `N` とその他全ての頂点とを結べば、`N` 以外の頂点の隣接点の和は

```math
N(N-3)/2 + N = N(N-1)/2
```

であり、`N` のそれは `1` ~ `N-1` の和なので

```math
N(N-1)/2
```

となり等しくなる。

計算量は `O(N^2)`

## C

:x:

オイラー閉路と次数 6 まで気づき、次数 4 以上が 3 つあればよいことも気づいたが、次数 4 以上が 2 つのときを考えてなかった。

- オイラー閉路は自明。(=> 全ての頂点は次数が偶数 (0 含まない))
- 次数 6 以上の頂点があれば自明。=> OK
- 次数 4 の点が 3 つ以上 (ooo みたいな形) => OK
- 次数 4 の点が 2 つ (a, b とする)
  - a-b 間のパスが 2 つ => それぞれ互いを含まないサーキットを持つので計 3 つもてる OK
  - a-b 間のパスが 4 つ => 高々 2 つのサーキット NG
- 次数 4 の点が 1 つ => 高々 2 つ。NG
- 次数 2 の点のみ => 高々 1 つ。NG

次数 4 の点が 2 つのときの「パスが 2 つ」という判定の実装が判らず、[ここ](http://drken1215.hatenablog.com/entry/2019/03/28/161000)で説明されていた「もう一方を通らずに一周して帰ってくれば OK」な実装をまねした。

`O(N+M)`

## D

:x:

左シフトは一番左の要素を右側に移す操作、右シフトは一番右の要素を右側に移す操作という考え方ができなかった。

左シフト => 右への移動 / 右シフト => 左への移動として、`1 ~ N` の要素をどの開区間にいどうするかを考える DP に落とす。

たとえば、`{1 3 4 5 2 6}` なら、`2` を `(1, 2)` の開区間に移動したい。

`O(N^2)`

## E

:x:

醜さがに関して二分探索しようと思ったが、醜さの最大値 `Z` を固定した時にそれを実現できるかどうかの判定で `O(N)` を満たすようなものを考えつかなかった。

結局、解説通りに実装。

解説されていなかったペアの組み替えが最適値を導く、つまりは組み替えによって醜さの最大値がそれ以下になることを各ペアについて証明しておく。以下、`0 <= x <= y <= z <= w < M` として、青色ペアを `B()` 赤色ペアを `R()` で表わすことにする。

- `B(x, y)`, `B(z, w)` -> `B(x, w)`, `B(y, z)`

  ```math
  x <= z <-> x + w <= z + w
  したがって、(x, w) の組は青かつその醜さは B(z, w) 以下である。
  y <= w <-> y + z <= z + w
  したがって、(y, z) の組は青かつその醜さは B(z, w) 以下である。

  以上よりこの組み替えは正しい。
  ```

- `B(x, z)`, `B(y, w)` -> `B(x, w)`, `B(y, z)`

  ```math
  x <= y <-> x + w <= y + w
  したがって、(x, w) の組は青かつその醜さは B(y, w) 以下である。
  z <= w <-> y + z <= y + w
  したがって、(y, z) の組は青かつその醜さは B(y, w) 以下である。

  以上よりこの組み替えは正しい。
  ```

- `R(x, y)`, `R(z, w)` -> `R(x, w)`, `R(y, z)`

  ```math
  y <= w <-> M <= x + y <= x + w
  x <= z <-> M <= x + w <= z + w < 2M
  したがって、(x, w) の組は赤かつその醜さは R(z, w) 以下である。
  x <= z <-> M <= x + y <= y + z
  y <= w <-> M <= y + z <= z + w
  したがって、(y, z) の組は赤かつその醜さは R(z, w) 以下である。

  以上よりこの組み替えは正しい。
  ```

- `R(x, z)`, `R(y, w)` -> `R(x, w)`, `R(y, z)`

  ```math
  z <= w <-> M <= x + z <= x + w
  x <= y <-> M <= x + w <= y + w
  したがって、(x, w) の組は赤かつその醜さは R(y, w) 以下である。
  x <= y <-> M <= x + z <= y + z
  z <= w <-> M <= y + z <= y + w
  したがって、(y, z) の組は赤かつその醜さは R(y, w) 以下である。

  以上よりこの組み替えは正しい。
  ```

- `B(x, z)`, `R(y, w)` -> `B(x, y)`, `R(z, w)`

  ```math
  y <= z <-> x + y <= x + z < M
  したがって、(x, y) の組は青かつその醜さは B(x, z) 以下である。
  y <= z <-> M <= y + w <= z + w
  より、(z, w) の組は赤。
  また、
  w < M <-> w - M < 0 < x <-> z + w - M < z + x
  M <= z + w < 2M <-> 0 <= z + w - M < M
  より
  z + w = z + w - M < x + z (mod M)
  したがって、(z, w) の組の醜さは B(x, z) 以下である。

  以上より正しい。
  ```

- `B(x, w)`, `R(y, z)` -> `B(x, y)`, `R(z, w)`

  ```math
  y <= w <-> x + y <= x + w < M
  したがって、(x, y) の組は青かつその醜さは B(x, w) 以下である。
  y <= w <-> M <= y + z <= z + w
  より、(z, w) の組は赤。また、
  z < M <-> z - M < 0 < x <-> z + w - M < x + w
  M <= z + w < 2M <-> 0 <= z + w - M < M
  より
  z + w = z + w - M < x + w (mod M)
  したがって、(z, w) の組の醜さは B(x, w) 以下である。

  以上より正しい。
  ```

- `R(x, w)`, `B(y, z)` -> `B(x, y)`, `R(z, w)`

  ```math
  x <= z <-> x + y < y + z < M
  したがって、(x, y) の組は青かつその醜さは B(y, z) 以下である。
  x <= z <-> M <= x + w <= z + w
  したがって、(z, w) の組は赤。また、
  w < M <-> w - M < 0 < y <-> z + w - M < y + z
  M <= z + w < 2M <-> 0 <= z + w - M < M
  より
  z + w = z + w - M < y + z (mod M)
  したがって、(z, w) の組の醜さは B(y, z) 以下である。

  以上より正しい。
  ```

また、「境界線が左であるほど青のペアができやすく、赤のペアができにくい」は、境界線の位置の値と `A` 内の最大値・最小値のペアを考えれば自明。「境界線が左であるほど醜さの最大値が小さくなる」は、赤の各ペアの右側を固定するとどのペアも相手が小さくなるから赤の醜さの最大値は小さくなり、青の各ペアの左側を固定するとこれもまた相手が小さくなるから青の醜さの最大値は小さくなる。結果として境界線が左に行くほど全体の最大値が小さくなることも自明。

計算量はソートが `O(N logN)` 二分探索が `O(logN)` チェックが `O(N)` なので、`O(N logN)`。

## F

:x:

さっぱりわからなかった。`O(N)`
