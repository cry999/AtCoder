# AtCoder Grand Contest 032

## A

:o:

現在の数列 `A` を右から見ていき最初にインデックスと値が一致する数字が今回の操作で挿入された数字。なぜなら、インデックスと値が一致する数字 `i` `j` (`i < j`) が見つかったとき `i` が今回の操作で挿入された数字だとすると、前回の数列では `j` のインデックスは `j-1` でありそれ以前の操作でも `j` のインデックスは `j-1` 以下であり、`j` となることがない、つまりは `j` を挿入する操作が存在しないことになるからである。

計算量は `O(N^2)`


## B

:o:

`N` が偶数の時、`i` は `N+1-i` 以外の頂点と結べば隣接点の和は `(N+1)(N-2)/2` となり、`i` に依存しないため全て同じになる。

`N` が奇数の時、`N` を抜いた `N-1` 個の頂点に対して偶数の場合の処理をする。このとき、`N` 以外の頂点はその隣接点の和は `N(N-3)/2` となってい。この状態で `N` とその他全ての頂点とを結べば、`N` 以外の頂点の隣接点の和は

```math
N(N-3)/2 + N = N(N-1)/2
```

であり、`N` のそれは `1` ~ `N-1` の和なので

```math
N(N-1)/2
```

となり等しくなる。

計算量は `O(N^2)`


## C

:x:

オイラー閉路と次数 6 まで気づき、次数 4 以上が 3 つあればよいことも気づいたが、次数 4 以上が 2 つのときを考えてなかった。

- オイラー閉路は自明。(=> 全ての頂点は次数が偶数 (0 含まない))
- 次数 6 以上の頂点があれば自明。=> OK
- 次数 4 の点が 3 つ以上 (ooo みたいな形) => OK
- 次数 4 の点が 2 つ (a, b とする)
  - a-b 間のパスが 2 つ => それぞれ互いを含まないサーキットを持つので計 3 つもてる OK
  - a-b 間のパスが 4 つ => 高々 2 つのサーキット NG
- 次数 4 の点が 1 つ => 高々 2 つ。NG
- 次数 2 の点のみ => 高々 1 つ。NG

次数 4 の点が 2 つのときの「パスが 2 つ」という判定の実装が判らず、[ここ](http://drken1215.hatenablog.com/entry/2019/03/28/161000)で説明されていた「もう一方を通らずに一種して帰ってくれば OK」な実装をまねした。

`O(N+M)`

## D

:x:

左シフトは一番左の要素を右側に移す操作、右シフトは一番右の要素を右側に移す操作という考え方ができなかった。

左シフト => 右への移動 / 右シフト => 左への移動として、`1 ~ N` の要素をどの開区間にいどうするかを考える DP に落とす。

たとえば、`{1 3 4 5 2 6}` なら、`2` を `(1, 2)` の開区間に移動したい。

`O(N^2)`

## E

TODO: not implemented

## F

TODO: not implemented

