# Iroha Chan Contest day1

## A

:o:

問題文通り。`O(1)`

## B

:o:

問題文通りシミュレーションしても間に合うが(`O(K)`) `|S|` 回以上の場合は `K % |S|` 回に短縮できる。`O(min(|S|, K))`

## C

:o:

問題文通り。`O(1)`

## D

:o:

援軍を大きい順に並べた時、奇数番目が高橋くんの援軍になり偶数番目が青木くんの援軍となる。`O(N logN)`

## E

:o:

最後にデートした日から次の記念日までの間の日数に応じてその間のデート回数を決める。計算の簡単のために `0` 日目と `N+1` 日目をデートした日として追加すると良い。`O(B)`

## F

:o:

素因数分解しながら、小さい順に素因数を突っ込んでいく。数列の最後の要素は使っていない素因数全部の積。`O(logN)`

## G

:o:

`dp[m][n] = m 回目の訪問を n 日目に行う場合の最大値` とすると `dp[m][n] = max(dp[m-1][n-k] + A[n])` となる。`O(NMK)`

## H

:x:

コーナーケースが多くて全てに気づけなかった。`O(log N)`

## I

:o:

基本的にはただの `dijkstra` 法。ただし、前回の移動で利用した `C` と今回利用する `C` の比較を行って移動に利用する距離を算出する。`O(E + V logV)`

## J

:x:

バイナリ列は前半部分(ながさ `M`)だけ考えればよく、ここに含まれる `1` の個数が `x` であるとする。この時、転倒数 `K` は以下のように計算される。

1. `N` is even

   ```math
   2x(M-x) = K
   => x = (M +- sqrt(M^2 - 2K)) / 2
   ```

1. N is odd

   1. center is 0

      ```math
      2x(M-x) + x = K
      => x = (2M+1 +- sqrt((2M+1)^2 - 8K)) / 4
      ```

   1. center is 1

      ```math
      2x(M-x) + (M-x) = K
      => x = (2M-1 +- sqrt((2M-1)^2 - 8(K-M))) / 4
      ```

このように求めた `x` について組み合わせ `(M, x)` を求めれば良い。ただし、`x` が整数になるようにチェックしながら計算する。整数にならない場合は該当するものなしとみなす。

## K

:x:

逆順に処理して桁数を利用した `dp` にするんだろうなとは思ったが、その実装が思いつかなかった。`O(N + M_1 + ... + M_N)`

## L

:x:

二分探索が思いつかない。`O(N logN logA)`
